<html>
<meta charset="utf-8">
<style>
    .node {
        stroke: #fff;
        stroke-width: 1.5px;
    }
    
    .link {
        fill: none;
        stroke: #bbb;
    }
    
    .link.active {
        stroke: red;
        stroke-width: 2px;
        stroke-opacity: 1;
    }
    
    .node.active {
        stroke: red;
        stroke-width: 1px;
    }
</style>

<body>
    <script src="http://d3js.org/queue.v1.min.js"></script>

    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script>
        var width = 960,
            height = 500;

        var color = d3.scale.category10();

        var force = d3.layout.force()
            .linkDistance(30)
            .linkStrength(2)
            .size([width, height]);

        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);

        //        queue()
        //            .defer(d3.json, 'data/az_flare2.json') // topojson polygons
        //            .await(visualize);

        d3.csv("az_s2t_100.csv", function visualize(error, data) {

            graph = {
                "nodes": [],
                "links": []
            };

            data.forEach(function (d) {
                graph.nodes.push({
                    "name": d.b1
                });
                graph.nodes.push({
                    "name": d.b2
                });
                graph.links.push({
                    "source": d.b1,
                    "target": d.b2,
                    "value": +d.common_count
                });
            });

            graph.nodes = d3.keys(d3.nest()
                .key(function (d) {
                    return d.name;
                })
                .map(graph.nodes));

            graph.links.forEach(function (d, i) {
                graph.links[i].source = graph.nodes.indexOf(graph.links[i].source);
                graph.links[i].target = graph.nodes.indexOf(graph.links[i].target);
            });

            graph.nodes.forEach(function (d, i) {
                graph.nodes[i] = {
                    "name": d
                };
            });

            console.log("loaded")
                //            var nodeMap = {};
                //            graph.nodes.forEach(function (x) {
                //                nodeMap[x.name] = x;
                //            });
                //            graph.links = graph.links.map(function (x) {
                //                console.log(nodeMap[x.b1] + " " + nodeMap[x.b2]);
                //                return {
                //                    source: nodeMap[x.b1],
                //                    target: nodeMap[x.b2],
                //                    value: x.common_count
                //                };
                //            });
                //            var nodes = graph.nodes.slice();
                //            var links = [];
                //            var bilinks = [];
                //            //            console.log(JSON.stringify(graph.nodes.slice()[0]));
                //            graph.links.forEach(function (link) {
                //                var s = link.source,
                //                    t = link.target,
                //                    i = {}; // intermediate node
                //                nodes.push(i);
                //                links.push({
                //                    source: s,
                //                    target: i
                //                }, {
                //                    source: i,
                //                    target: t
                //                });
                //                bilinks.push([s, i, t]);
                //            });


            console.log(JSON.stringify(graph));

            force
                .nodes(graph.nodes)
                .links(graph.links)
                .start();

            console.log("loaded")
            var link = svg.selectAll(".link")
                .data(graph.links)
                .enter().append("line")
                .attr("class", "link")
                .attr("x1", function (d) {
                    return d.source.x;
                })
                .attr("y1", function (d) {
                    return d.source.y;
                })
                .attr("x2", function (d) {
                    return d.target.x;
                })
                .attr("y2", function (d) {
                    return d.target.y;
                });

            var node = svg.selectAll(".node")
                .data(graph.nodes)
                .enter()
                .append("circle")
                .attr("class", "node")
                .attr("r", 5)
                .style("fill", function (d, i) {
                    return color(i & 3);
                })
                .call(force.drag)
                .on("mouseover", nodeMouseover)
                .on("mouseout", nodeMouseout);

            //           
            // console.log(labels);
            //            node.append("title")
            //                .text(function (d) {
            //                    return d.name;
            //                });


            var linkedByIndex = {};
            graph.links.forEach(function (d) {

                linkedByIndex[d.source.index + "," + d.target.index] = 1;
                linkedByIndex[d.target.index + "," + d.source.index] = 1;
                console.log(d.source.index + "," + d.target.index + "-->" + linkedByIndex[d.source.index + "," + d.target.index]);

            });

            function neighboring(a, b) {
                console.log(a.index + "," + b.index + "-->" + linkedByIndex[a.index + "," + b.index]);
                return linkedByIndex[a.index + "," + b.index];
            }

            svg.selectAll("circle.node").on("click", function () {
                d3.selectAll("circle.node")
                    .attr("class", "node")
                    .attr("r", 5)
                    .style("fill", function (d, i) {
                        return color(i & 3);
                    })
                d3.select(this).attr('r', 8)
                    .style("stroke", "red");


            });

            function nodeMouseover(d) {
                svg.selectAll(".link").classed("active", function (p) {
                    return d3.select(this).classed("active") || p.source === d || p.target === d;
                });


                node.style("opacity", function (o) {
                    return neighboring(d, o) ? 1 : 0.4;
                });
                d3.select(this).classed("active", true).text(function (d) {
                    return d.b1;
                });


            }

            function nodeMouseout(d) {
                svg.selectAll(".link").classed("active", function (p) {
                    return false;
                });

                d3.select(this).classed("active", false).text(function (d) {
                    return d.b1;
                });

                node.style("opacity", function (o) {
                    return 1;
                });
            }

            force.on("tick", function () {
                //                link.attr("d", function (d) {
                //                    return "M" + d[0].x + "," + d[0].y + "S" + d[1].x + "," + d[1].y + " " + d[2].x + "," + d[2].y;
                //                });
                link.attr("x1", function (d) {
                        return d.source.x;
                    })
                    .attr("y1", function (d) {
                        return d.source.y;
                    })
                    .attr("x2", function (d) {
                        return d.target.x;
                    })
                    .attr("y2", function (d) {
                        return d.target.y;
                    });

                node.attr("transform", function (d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });

            });

        });
    </script>